pragma solidity ^0.4.24;

/*
 * @title  - Decentralised BlackJack
 * 
 * @author - Vutsal Singhal <vutsalsinghal[at]gmail[dot]com>
 * @author - Amit Panghal <panghalamit1892[at]gmail[dot]com>
 * 
 * @notice - 
 * @dev    - 
*/

contract BlackJack{
    uint public total_BetAmount;                                                // Total bet amount
    uint public minimum_bet;                                                    // Min  bet value;
    uint public max_wait;                                                       // Max wait after player's last move before ending the game
    uint public lastGameId;                                                     // Keep track of total no.of games in progress
    
    struct Game{
        bool gotPaid;                                                           // Player has already received winnings
        uint bet_amount;                                                        // Bet amount
        uint bet_start;                                                         // Time of the last move by the player
        uint8 player_score;                                                     // Total sum of player's cards value
        uint8 player_TotalCards;                                                // No. of cards opened by player
        uint8 dealer_score;                                                     // Total sum of dealer's cards value
        uint8 dealer_TotalCards;                                                // No. of cards opened by dealer
        uint8[8] player_cards;                                                  // Array of player's open cards
        uint8[8] dealer_cards;                                                  // Array of dealer's open cards
        uint8[13] deck_count;                                                   // Keep count of each of 13 cards
        address playerAddr;                                                     // Player's address
    }
    
    mapping (uint => Game) gameInfo;                                            // GameId to game instance
    mapping (address => uint) addrToGameId;                                     // Player's addr to gameId
    address private casino_owner;                                               // Owner of casino
    
    
    //----------------------------------------- Modifiers -----------------------------------------\\
    
    modifier isdealerBalanceSufficient (uint _totalBetAmt){                         // Check if dealer has sufficient balance to host Blackjack game               
        require(address(this).balance >= 2*_totalBetAmt, "Casino should have enough balance for gameplay");
        _;
    }
    
    modifier isPlayer{
        require(casino_owner != msg.sender, "only player can call game functions");
        _;
    }
    
    // Check if address is owner of contract
    modifier onlyOwner {
        require(msg.sender == casino_owner, "only owner can withdraw");
        _;
    }
    
    //----------------------------------------- Constructor -----------------------------------------\\
    constructor() public payable{
        casino_owner = msg.sender;
        minimum_bet = 0.01 ether;                                               // Default values; can be changed using changeValues()
        max_wait = 200;
        total_BetAmount = 0;
        lastGameId = 0;
    }
    
    // Entry point for placing bet
    function placeBet() public payable isdealerBalanceSufficient(msg.value+total_BetAmount) returns(uint8[8] playerCards, uint8[8] dealerCards){
        require(msg.value >= minimum_bet, "Bet amt should be >= min bet amt");  // Check if player has placed atleast the min beting amount
        require(addrToGameId[msg.sender] == 0, "Play already going on");        // Check if player is not already playing
        
        total_BetAmount += msg.value;                                           // Total betting amount by all players

        addrToGameId[msg.sender] = ++lastGameId;                                // Create a new game instance

        gameInfo[lastGameId].playerAddr = msg.sender;
        gameInfo[lastGameId].bet_amount = msg.value;
        gameInfo[lastGameId].gotPaid = false;

        for(uint8 i = 0; i < 13; i++) {
            gameInfo[lastGameId].deck_count[i] = 4;
        }

        uint8 drawCard1 = _shuffleAndTake(lastGameId);
        uint8 drawCard2 = _shuffleAndTake(lastGameId);
        uint8 drawCard3 = _shuffleAndTake(lastGameId);

        gameInfo[lastGameId].dealer_cards[gameInfo[lastGameId].dealer_TotalCards++] = drawCard1;     // Dealer draws 1 card
        gameInfo[lastGameId].player_cards[gameInfo[lastGameId].player_TotalCards++] = drawCard2;     // Player draws 2 cards
        gameInfo[lastGameId].player_cards[gameInfo[lastGameId].player_TotalCards++] = drawCard3;
        
        gameInfo[lastGameId].dealer_score += drawCard1;
        gameInfo[lastGameId].player_score += (drawCard2 + drawCard3);
        
        for (i = 0; i < gameInfo[lastGameId].player_TotalCards; i++) {
            if (gameInfo[lastGameId].player_cards[i] == 1 && gameInfo[lastGameId].player_score + 10 <= 21)
                gameInfo[lastGameId].player_score += 10;                        // Check for Ace; Ace = 1 or 11
        }

        if (gameInfo[lastGameId].player_score == 21){
            revealAndStop(lastGameId);
        }else{
            gameInfo[lastGameId].bet_start = now;
        }
        
        return (gameInfo[lastGameId].player_cards, gameInfo[lastGameId].dealer_cards);
    }
    
    // Hit, called by player
    function hit() public isPlayer returns(uint8 card, uint8[8] playerCards){
        require(addrToGameId[msg.sender] != 0, "Player is not playing");        // Check if player has started playing
        uint gameId = addrToGameId[msg.sender];                                 // Get player's game instance

        //if (gameInfo[gameId].playerAddr == msg.sender){                       // Check if the same player is calling hit
        if(now > (gameInfo[gameId].bet_start + max_wait)){                      // Player has to hit withen max_wait period
            revealAndStop(gameId);
        } else {
            card = _shuffleAndTake(gameId);
            gameInfo[gameId].player_cards[gameInfo[gameId].player_TotalCards++] = card;
            gameInfo[gameId].player_score += card;

            if (gameInfo[gameId].player_score > 21){                            // Busted!
                reset_game(gameId);
            } else{
                gameInfo[gameId].bet_start = now;
            }
        }
        
        return (card, gameInfo[gameId].player_cards);
        //}else
        //  return (0,[]);
    }

    // view function to check player's cards
    function viewPlayerCards() view external isPlayer returns(uint GameID, uint playerScore, uint8[8] playerCards, uint8[8] dealerCards, uint time_left){
        require(addrToGameId[msg.sender] != 0, "Player is not playing");        // Check if player has started playing
        uint gameId = addrToGameId[msg.sender];                                 // Get player's game instance

        time_left = 0;
        if ((gameInfo[gameId].bet_start + max_wait - now) > 0)
            time_left = gameInfo[gameId].bet_start + max_wait - now;
        return (gameId, gameInfo[gameId].player_score, gameInfo[gameId].player_cards, gameInfo[gameId].dealer_cards, time_left);
    }

    // Function to be called by player when he wants to stop
    function revealAndStop(uint gameId) public isPlayer returns(bool result, uint8 playerScore, uint8 dealerScore){
       return (_endgame(gameId), gameInfo[gameId].player_score, gameInfo[gameId].dealer_score);
    }
    
    // Function to check cards and end game
    function _endgame(uint gameId) internal returns(bool result){
        require(gameInfo[gameId].gotPaid == false, 'Player is already paid!');  // Check if player has received winnings
        result = false;

        for (uint8 i = 0; i < gameInfo[gameId].player_TotalCards; i++) {
            // Ace = 1 or 11
            if (gameInfo[gameId].player_cards[i] == 1 && gameInfo[gameId].player_score + 10 <= 21)
                gameInfo[gameId].player_score += 10;
        }

        if (gameInfo[gameId].player_score > 21 ){                               // Busted!
            result = false;
        } else{
            _revealDealerCards(gameId);                                         // Dealer draws till dealer_score <= 17

            if(gameInfo[gameId].dealer_score > 21 || gameInfo[gameId].player_score > gameInfo[gameId].dealer_score){
                // Player wins 2*bet_amount
                gameInfo[gameId].gotPaid = true;
                result = true;
                gameInfo[gameId].playerAddr.transfer(2*gameInfo[gameId].bet_amount);
            } else if(gameInfo[gameId].player_score == gameInfo[gameId].dealer_score){
                // Player gets back his bet_amount
                gameInfo[gameId].gotPaid = true;
                result = true;
                gameInfo[gameId].playerAddr.transfer(gameInfo[gameId].bet_amount);
            }
        }

        reset_game(gameId);
    }

    // Reveals draws of dealer, dealer draws all cards at the end, to prevent revealing
    function _revealDealerCards(uint gameId) internal{
        uint8 card;
        uint8 _totAces = 0;
        
        while (gameInfo[gameId].dealer_score <= 17){                            // Dealer draws till dealer_score <= 17
            card = _shuffleAndTake(gameId);
            gameInfo[gameId].dealer_cards[gameInfo[gameId].dealer_TotalCards++] = card;
            gameInfo[gameId].dealer_score += card;
            if (card == 1) _totAces++;
        }
    
        if (gameInfo[gameId].dealer_score < 21){
            for (uint8 i = 0; i < _totAces; i++){
                if (gameInfo[gameId].dealer_score + 10 <= 21) gameInfo[gameId].dealer_score += 10;
            }
        }
    }

    // Function to help in random card pick
    function _getRandom() internal view returns(uint rand){
        bytes32 hashval = keccak256(abi.encodePacked(now, lastGameId));
        rand = uint256(hashval);
    }

    // Pick a card from the deck
    function _shuffleAndTake(uint gameId) internal returns(uint8 card) {
        bool card_found = false;
        while(!card_found){
            uint _rand = (_getRandom() % 52) + 1;
            if (gameInfo[gameId].deck_count[_rand % 13] > 0){                   // Check if any of the suits is left
                card = uint8(_rand % 13 + 1);

                if (card > 10){                                                 // All face cards have value = 10
                    card = 10;
                }

                gameInfo[gameId].deck_count[_rand % 13]--;
                card_found = true;
            }
        }
    }

    function ifPlayerUnresponsive(uint gameId) external onlyOwner{
        if(now > gameInfo[gameId].bet_start + max_wait) {                       // Owner can end game (after wait period is over) if player is unresponsive
            revealAndStop(gameId);
        } else {

        }
    }

    function changeValues(uint _minimum_bet, uint _max_wait) external onlyOwner{
        minimum_bet = _minimum_bet;
        max_wait = _max_wait;
    }

    function reset_game(uint gameId) internal{
    	total_BetAmount -= gameInfo[gameId].bet_amount;
        addrToGameId[gameInfo[gameId].playerAddr] = 0;
        delete gameInfo[gameId];
        /*
        playerAddr = 0;
        bet_amount = 0;
        player_TotalCards = 0;
        bet_start = 0;
        
        for (uint8 i = 0; i < 13; i++){
            deck_count[i] = 4;
        }
        */
    }
    
    function transferToDealer() public payable{}                                // Anyone can send Ether to contract
   
    function transferFromDealer(uint _amount) external onlyOwner{
        //require(playerAddr == 0, "Can't withdraw while game in progress");    // Check if no game in progress
        casino_owner.transfer(_amount);
    }
    
    function kill() public onlyOwner{                                           // destroy contract
        selfdestruct(casino_owner);
    }
}
